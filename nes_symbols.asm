.IFNDEF _NES_SYMBOLS_
.DEFINE _NES_SYMBOLS_

;
;  PPU MEMORY MAP
;  $0000-$0FFF	$1000	PATTERN TABLE 0
;  $1000-$1FFF	$1000	PATTERN TABLE 1
;  $2000-$23FF	$0400	NAMETABLE 0
;  $2400-$27FF	$0400	NAMETABLE 1
;  $2800-$2BFF	$0400	NAMETABLE 2
;  $2C00-$2FFF	$0400	NAMETABLE 3
;  $3000-$3EFF	$0F00	MIRRORS OF $2000-$2EFF
;  $3F00-$3F1F	$0020	PALETTE RAM INDEXES
;  $3F20-$3FFF	$00E0	MIRRORS OF $3F00-$3F1F
;

;
; PPU REGISTERS
;
PPUCTRL   = $2000
PPUMASK   = $2001
PPUSTATUS = $2002
OAMADDR   = $2003       ; WRITE THE ADDRESS OF OAM YOU WANT TO ACCESS HERE. 
                        ; MOST GAMES JUST WRITE $00 HERE AND THEN USE OAMDMA. 
                        ; (DMA IS IMPLEMENTED IN THE 2A03/7 CHIP AND WORKS BY REPEATEDLY WRITING TO OAMDATA)
OAMDATA   = $2004       ; WRITE OAM DATA HERE. WRITES WILL INCREMENT OAMADDR AFTER THE WRITE; 
                        ; READS DURING VERTICAL OR FORCED BLANKING RETURN THE VALUE FROM OAM AT THAT ADDRESS BUT DO NOT INCREMENT.
                        ; DO NOT WRITE DIRECTLY TO THIS REGISTER IN MOST CASES. 
PPUSCROLL = $2005       ; THIS REGISTER IS USED TO CHANGE THE SCROLL POSITION, 
                        ; THAT IS, TO TELL THE PPU WHICH PIXEL OF THE NAMETABLE SELECTED THROUGH PPUCTRL 
                        ; SHOULD BE AT THE TOP LEFT CORNER OF THE RENDERED SCREEN. 
                        ; TYPICALLY, THIS REGISTER IS WRITTEN TO DURING VERTICAL BLANKING, SO THAT THE NEXT FRAME 
                        ; STARTS RENDERING FROM THE DESIRED LOCATION, BUT IT CAN ALSO BE MODIFIED DURING RENDERING 
                        ; IN ORDER TO SPLIT THE SCREEN. CHANGES MADE TO THE VERTICAL SCROLL DURING RENDERING 
                        ; WILL ONLY TAKE EFFECT ON THE NEXT FRAME. (WRITE X, WRITE Y)
PPUADDR   = $2006       ; BECAUSE THE CPU AND THE PPU ARE ON SEPARATE BUSES, NEITHER HAS DIRECT ACCESS TO THE OTHER'S MEMORY. 
                        ; THE CPU WRITES TO VRAM THROUGH A PAIR OF REGISTERS ON THE PPU. 
                        ; FIRST IT LOADS AN ADDRESS INTO PPUADDR, AND THEN IT WRITES REPEATEDLY TO PPUDATA TO FILL VRAM.
                        ; AFTER READING PPUSTATUS TO RESET THE ADDRESS LATCH, WRITE THE 16-BIT ADDRESS OF VRAM YOU WANT TO ACCESS HERE,
                        ; UPPER BYTE FIRST.
PPUDATA   = $2007       ; VRAM READ/WRITE DATA REGISTER. AFTER ACCESS, THE VIDEO MEMORY ADDRESS WILL INCREMENT BY AN AMOUNT DETERMINED BY BIT 2 PPUCTRL::VRAM_INC OF PPUCTRL.
OAMDMA    = $4014       ; THIS PORT IS LOCATED ON THE CPU. WRITING $XX WILL UPLOAD 256 BYTES OF DATA FROM CPU PAGE $XX00-$XXFF TO THE INTERNAL PPU OAM. 
                        ; THIS PAGE IS TYPICALLY LOCATED IN INTERNAL RAM, COMMONLY $0200-$02FF, BUT CARTRIDGE RAM OR ROM CAN BE USED AS WELL.

;
; IO REGISTERS
;
NESIOREG1 = $4016         ; CONTROLLER INPUT IS INITIATED 
                        ; BY WRITING A 1 FOLLOWED BY A 0 TO THIS ADDRESS. 
NESIOREG2 = $4017

; ENUMS
.SCOPE BITS
        BIT_0     = 1
        BIT_1     = 2
        BIT_2     = 4
        BIT_3     = 8
        BIT_4     = 16
        BIT_5     = 32
        BIT_6     = 64
        BIT_7     = 128
.ENDSCOPE

.SCOPE  PPUCTRL
        NT_BASE_0    = BITS::BIT_0 ;BASE NAMETABLE ADDRESS (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
        NT_BASE_1    = BITS::BIT_1 
        VRAM_INC     = BITS::BIT_2 ; VRAM ADDRESS INCREMENT PER CPU READ/WRITE OF PPUDATA (0: ADD 1, GOING ACROSS; 1: ADD 32, GOING DOWN)
        PT_ADDR_SPR  = BITS::BIT_3 ; SPRITE PATTERN TABLE ADDRESS FOR 8X8 SPRITES (0: $0000; 1: $1000; IGNORED IN 8X16 MODE)
        PT_ADDR_BG   = BITS::BIT_4 ; BACKGROUND PATTERN TABLE ADDRESS (0: $0000; 1: $1000)
        SPRITE_SIZE  = BITS::BIT_5 ; SPRITE SIZE (0: 8X8 PIXELS; 1: 8X16 PIXELS)
        MASTER_SLAVE = BITS::BIT_6 ; PPU MASTER/SLAVE SELECT (0: READ BACKDROP FROM EXT PINS; 1: OUTPUT COLOR ON EXT PINS)
        NMI_ENABLE   = BITS::BIT_7 ; GENERATE AN NMI AT THE START OF THE VERTICAL BLANKING INTERVAL (0: OFF; 1: ON)
.ENDSCOPE

.SCOPE  PPUMASK
        GREYSCALE    = BITS::BIT_0 ; GREYSCALE (0: NORMAL COLOR, 1: PRODUCE A GREYSCALE DISPLAY)
        SHOW_BG_8    = BITS::BIT_1 ; SHOW BACKGROUND IN LEFTMOST 8 PIXELS OF SCREEN, 0: HIDE
        SHOW_SPR_8   = BITS::BIT_2 ; SHOW SPRITES IN LEFTMOST 8 PIXELS OF SCREEN, 0: HIDE
        SHOW_BG      = BITS::BIT_3 ; SHOW BACKGROUND
        SHOW_SPR     = BITS::BIT_4 ; SHOW SPRITES
        EM_RED       = BITS::BIT_5 ; EMPHASIZE RED
        EM_GREEN     = BITS::BIT_6 ; EMPHASIZE GREEN
        EM_BLUE      = BITS::BIT_7 ; EMPHASIZE BLUE
.ENDSCOPE

.SCOPE  PPUSTATUS
        SPRITE_OVF   = BITS::BIT_5 ; SPRITE OVERFLOW. THE INTENT WAS FOR THIS FLAG TO BE SET
                                   ; WHENEVER MORE THAN EIGHT SPRITES APPEAR ON A SCANLINE, BUT A
                                   ; HARDWARE BUG CAUSES THE ACTUAL BEHAVIOR TO BE MORE COMPLICATED
                                   ; AND GENERATE FALSE POSITIVES AS WELL AS FALSE NEGATIVES; SEE
                                   ; PPU SPRITE EVALUATION. THIS FLAG IS SET DURING SPRITE
                                   ; EVALUATION AND CLEARED AT DOT 1 (THE SECOND DOT) OF THE
                                   ; PRE-RENDER LINE.
        SPRITE_0_HIT = BITS::BIT_6 ; SPRITE 0 HIT.  SET WHEN A NONZERO PIXEL OF SPRITE 0 OVERLAPS A NONZERO BACKGROUND PIXEL; CLEARED AT DOT 1 OF THE PRE-RENDER LINE.  USED FOR RASTER TIMING.
        VBLANK_START = BITS::BIT_7 ; VERTICAL BLANK HAS STARTED (0: NOT IN VBLANK; 1: IN VBLANK). SET AT DOT 1 OF LINE 241 (THE LINE *AFTER* THE POST-RENDER LINE); CLEARED AFTER READING PPUSTATUS AND AT DOT 1 OF THE PRE-RENDER LINE.
.ENDSCOPE

.SCOPE JOYPAD 
        BUTTON_A = BITS::BIT_7
        BUTTON_B = BITS::BIT_6
        SELECT   = BITS::BIT_5
        START    = BITS::BIT_4
        UP       = BITS::BIT_3
        DOWN     = BITS::BIT_2
        LEFT     = BITS::BIT_1
        RIGHT    = BITS::BIT_0
.ENDSCOPE 

.ENDIF