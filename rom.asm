
.INCLUDE "NES_SYMBOLS.ASM"
.INCLUDE "GAME_SYMBOLS.ASM"
.INCLUDE "IO.ASM"
.INCLUDE "HEADER.ASM"
.INCLUDE "RESET.ASM"
.INCLUDE "INTERRUPTS.ASM"
.SEGMENT "CODE"

MAIN:
    LDX #$FF        ; INITIALIZE IO BUFFER POINTERS
    STX WR_PTR
    STX RD_PTR

    LDA #(PPUCTRL::NMI_ENABLE | PPUCTRL::PT_ADDR_BG) ; INITIAL PPUCTRL WRITE HAS TO ENABLE NMI INTERRUPTS; SUBSEQUENT WRITES TO PPUCTRL WILL BE BUFFERED AND TAKE PLACE IN NMI
    STA PPUCTRL

    LDA #(PPUMASK::SHOW_BG | PPUMASK::SHOW_SPR | PPUMASK::SHOW_BG_8 | PPUMASK::SHOW_SPR_8) ; SUBSEQUENT WRITES TO PPUMASK WILL BE BUFFERED AND TAKE PLACE IN NMI
    STA PPUMASK

    CLI             ; RESPOND TO INTERRUPTS

LOAD_PALETTES:      ; UPDATE BACKGROUND AND SPRITE PALETTE DATA
    LDA #$20        ; NUMBER OF PALETTE DATA BYTES
    JSR WR_BUF 
    LDA #$3F        ; MSB PALETTE VRAM ADDRESS
    JSR WR_BUF
    LDA #$00        ; LSB PALETTE VRAM ADDRESS
    JSR WR_BUF 
    LDX #$00  
LOOP_PALETTE_DATA:      
    LDA PALETTE, X  ; WITH THE PALETTE DATA STORED IN ROM
    JSR WR_BUF
    INX
    CPX #$20
    BNE LOOP_PALETTE_DATA
    JSR CMD_SET
LOAD_BACKGROUND:
    LDA #$40
    JSR WR_BUF
    LDA #$20        ;
    JSR WR_BUF      ; POINT THE PPU TO THE PALLET VRAM ADDRESS 
    LDA #$00        ; THE ADDRESS LATCH SHOULD ALREADY BE CLEARED 
    STA WR_BUF     ; BY READING PPUSTATUS IN THE RESET ROUTINE
    LDA #$04
    LDY #$40
LOOP_BACKGROUND_DATA:
    JSR WR_BUF
    DEY
    BNE LOOP_BACKGROUND_DATA
    JSR CMD_SET

LOAD_ATTRIBUTES:
    LDA #$01
    JSR WR_BUF
    LDA #$23        ;
    JSR WR_BUF     ; POINT THE PPU TO THE PALLET VRAM ADDRESS 
    LDA #$C0        ; THE ADDRESS LATCH SHOULD ALREADY BE CLEARED 
    JSR WR_BUF     ; BY READING PPUSTATUS IN THE RESET ROUTINE
    LDA #(3 << 6) | (3 << 4) | (3 << 2) | (3 << 0)
    JSR WR_BUF
    JSR CMD_SET

    LDA #25
    STA OAM
    LDA #%00000001
    STA OAM+1
    LDA #%00000001
    STA OAM+2
    LDA #25
    STA OAM+3
    JSR OAM_SET

GAME_LOOP:
    JSR NMI_WAIT
    JSR READJOY
    LDA JOYPAD1
    BEQ GAME_LOOP
CHECK_RIGHT:
    LSR A
    BCC CHECK_LEFT
    JSR MOVE_RIGHT
CHECK_LEFT:
    LSR A
    BCC CHECK_DOWN
    JSR MOVE_LEFT
CHECK_DOWN:
    LSR A
    BCC CHECK_UP
    JSR MOVE_DOWN
CHECK_UP:
    LSR A 
    BCS MOVE_UP
    JMP GAME_LOOP
MOVE_RIGHT:
    INC OAM+3
    JSR OAM_SET
    JMP GAME_LOOP
    RTS
MOVE_LEFT:
    DEC OAM+3
    JSR OAM_SET
    JMP GAME_LOOP
    RTS
MOVE_UP:
    DEC OAM
    JSR OAM_SET
    JMP GAME_LOOP
    RTS
MOVE_DOWN:
    INC OAM
    JSR OAM_SET
    JMP GAME_LOOP
    RTS

;---------------------------------------
; Subroutine will signal when NMI handler is done
NMI_WAIT:
    LDA #BITS::BIT_7
    STA NMI_DONE
NMI_WAIT_LOOP:
    LDA NMI_DONE
    BMI NMI_WAIT_LOOP
    RTS
;---------------------------------------

OAM_SET:
LDA #BITS::BIT_7
STA OAMFLAG
RTS

CMD_SET:
LDA #BITS::BIT_7
STA PPUCMDFLAG
RTS

PPUMASK_SET:
LDA #BITS::BIT_7
STA PPUMASKFLAG
RTS

PPUCTRL_SET:
LDA #BITS::BIT_7
STA PPUCTRLFLAG
RTS

.SEGMENT "RODATA"
PALETTE: 
    .BYTE $22, $29, $1A, $0F, $22, $36, $17, $0F, $22, $30, $21, $0F, $22, $27, $17, $0F ; BACKGROUND
    .BYTE $22, $16, $27, $18, $22, $1A, $30, $27, $22, $16, $30, $27, $22, $0F, $36, $17 ; SPRITES

.SEGMENT "TILES"
.INCBIN "SPRITE.CHR"
.INCBIN "BACKGROUND.CHR"

.SEGMENT "VECTORS"
.ADDR NMI, RESET, IRQ